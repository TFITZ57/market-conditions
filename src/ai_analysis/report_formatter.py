import os
import re
import logging
import markdown
import json
from typing import Dict, List, Any, Optional, Union
from datetime import datetime
import io
from docx import Document
from docx.shared import Inches, Pt
from docx.enum.text import WD_ALIGN_PARAGRAPH
import base64
from fpdf import FPDF
import matplotlib.pyplot as plt

# Configure logger
logger = logging.getLogger(__name__)

def markdown_to_html(markdown_text: str) -> str:
    """
    Convert markdown text to HTML.
    
    Args:
        markdown_text (str): Markdown text.
    
    Returns:
        str: HTML text.
    """
    try:
        # Convert markdown to HTML
        html = markdown.markdown(markdown_text, extensions=['tables', 'fenced_code'])
        
        # Add CSS for styling
        styled_html = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="utf-8">
            <style>
                body {{
                    font-family: Arial, sans-serif;
                    line-height: 1.6;
                    color: #333;
                    max-width: 900px;
                    margin: 0 auto;
                    padding: 20px;
                }}
                h1, h2, h3, h4, h5, h6 {{
                    color: #2c3e50;
                    margin-top: 24px;
                    margin-bottom: 16px;
                }}
                h1 {{
                    font-size: 28px;
                    border-bottom: 1px solid #eee;
                    padding-bottom: 10px;
                }}
                h2 {{
                    font-size: 24px;
                    border-bottom: 1px solid #eee;
                    padding-bottom: 8px;
                }}
                h3 {{
                    font-size: 20px;
                }}
                h4 {{
                    font-size: 18px;
                }}
                p, ul, ol {{
                    margin-bottom: 16px;
                }}
                a {{
                    color: #4682b4;
                    text-decoration: none;
                }}
                a:hover {{
                    text-decoration: underline;
                }}
                pre {{
                    background-color: #f5f8fa;
                    border: 1px solid #ddd;
                    border-radius: 3px;
                    padding: 16px;
                    overflow: auto;
                }}
                code {{
                    background-color: #f5f8fa;
                    border-radius: 3px;
                    padding: 2px 4px;
                    font-family: Consolas, monospace;
                }}
                table {{
                    border-collapse: collapse;
                    width: 100%;
                    margin-bottom: 20px;
                }}
                th, td {{
                    border: 1px solid #ddd;
                    padding: 8px 12px;
                    text-align: left;
                }}
                th {{
                    background-color: #f2f2f2;
                    font-weight: bold;
                }}
                tr:nth-child(even) {{
                    background-color: #f9f9f9;
                }}
                blockquote {{
                    border-left: 4px solid #ddd;
                    padding-left: 16px;
                    color: #666;
                    margin-left: 0;
                    margin-right: 0;
                }}
                img {{
                    max-width: 100%;
                }}
                .footer {{
                    margin-top: 40px;
                    padding-top: 20px;
                    border-top: 1px solid #eee;
                    font-size: 12px;
                    color: #777;
                    text-align: center;
                }}
            </style>
        </head>
        <body>
            {html}
            <div class="footer">
                <p>Generated by Fairfield County Housing Market Analysis on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
            </div>
        </body>
        </html>
        """
        
        return styled_html
    
    except Exception as e:
        logger.error(f"Error converting markdown to HTML: {str(e)}")
        return f"<p>Error converting markdown to HTML: {str(e)}</p>"

def markdown_to_docx(markdown_text: str, images: Dict[str, bytes] = None) -> Document:
    """
    Convert markdown text to a Word document.
    
    Args:
        markdown_text (str): Markdown text.
        images (Dict[str, bytes], optional): Dictionary of image data keyed by image ID. Defaults to None.
    
    Returns:
        docx.Document: Word document.
    """
    try:
        # Create a new Word document
        doc = Document()
        
        # Set document properties
        doc.core_properties.title = "Fairfield County Housing Market Analysis"
        doc.core_properties.author = "Fairfield Housing Analysis Application"
        doc.core_properties.created = datetime.now()
        
        # Split markdown into lines
        lines = markdown_text.strip().split('\n')
        
        # Process lines
        in_code_block = False
        in_list = False
        list_items = []
        in_table = False
        table_header = []
        table_rows = []
        
        for line in lines:
            # Handle headers
            if re.match(r'^#{1,6}\s', line):
                # End any current list
                if in_list:
                    for item in list_items:
                        p = doc.add_paragraph(style='List Bullet')
                        p.add_run(item)
                    list_items = []
                    in_list = False
                
                # End any current table
                if in_table:
                    table = doc.add_table(rows=1, cols=len(table_header))
                    table.style = 'Table Grid'
                    
                    # Add header row
                    header_cells = table.rows[0].cells
                    for i, header in enumerate(table_header):
                        header_cells[i].text = header
                    
                    # Add data rows
                    for row_data in table_rows:
                        row_cells = table.add_row().cells
                        for i, cell in enumerate(row_data):
                            if i < len(row_cells):
                                row_cells[i].text = cell
                    
                    doc.add_paragraph()  # Add space after table
                    table_header = []
                    table_rows = []
                    in_table = False
                
                # Get header level
                level = len(re.match(r'^(#+)', line).group(1))
                text = line[level:].strip()
                
                # Add header with appropriate style
                if level == 1:
                    p = doc.add_heading(text, 0)  # Title
                elif level == 2:
                    p = doc.add_heading(text, 1)
                else:
                    p = doc.add_heading(text, level - 1)
            
            # Handle code blocks
            elif line.startswith('```'):
                if in_code_block:
                    # End code block
                    in_code_block = False
                    doc.add_paragraph()  # Add space after code block
                else:
                    # Start code block
                    in_code_block = True
                    # Add space before code block
                    doc.add_paragraph()
            
            elif in_code_block:
                # Add code line with monospaced font
                p = doc.add_paragraph()
                p.add_run(line).font.name = 'Courier New'
            
            # Handle lists
            elif line.strip().startswith('- ') or line.strip().startswith('* '):
                if not in_list:
                    # Start new list
                    in_list = True
                    # End any current code block
                    if in_code_block:
                        in_code_block = False
                        doc.add_paragraph()  # Add space after code block
                
                # Add list item
                item_text = line.strip()[2:].strip()
                list_items.append(item_text)
            
            # Handle tables
            elif line.strip().startswith('|') and line.strip().endswith('|'):
                if not in_table:
                    # Start new table
                    in_table = True
                    # End any current list
                    if in_list:
                        for item in list_items:
                            p = doc.add_paragraph(style='List Bullet')
                            p.add_run(item)
                        list_items = []
                        in_list = False
                    # End any current code block
                    if in_code_block:
                        in_code_block = False
                        doc.add_paragraph()  # Add space after code block
                
                # Parse table row
                cells = [cell.strip() for cell in line.strip()[1:-1].split('|')]
                
                if len(table_header) == 0:
                    # First row is header
                    table_header = cells
                elif all(cell.strip() == '-' * len(cell.strip()) for cell in cells):
                    # Separator row, ignore
                    pass
                else:
                    # Data row
                    table_rows.append(cells)
            
            # Handle blank lines
            elif line.strip() == '':
                # End any current list
                if in_list:
                    for item in list_items:
                        p = doc.add_paragraph(style='List Bullet')
                        p.add_run(item)
                    list_items = []
                    in_list = False
                
                # Add paragraph if not in code block
                if not in_code_block and not in_table:
                    doc.add_paragraph()
            
            # Regular paragraph
            else:
                # End any current list
                if in_list:
                    for item in list_items:
                        p = doc.add_paragraph(style='List Bullet')
                        p.add_run(item)
                    list_items = []
                    in_list = False
                
                # End any current table
                if in_table and line.strip() != '':
                    table = doc.add_table(rows=1, cols=len(table_header))
                    table.style = 'Table Grid'
                    
                    # Add header row
                    header_cells = table.rows[0].cells
                    for i, header in enumerate(table_header):
                        header_cells[i].text = header
                    
                    # Add data rows
                    for row_data in table_rows:
                        row_cells = table.add_row().cells
                        for i, cell in enumerate(row_data):
                            if i < len(row_cells):
                                row_cells[i].text = cell
                    
                    doc.add_paragraph()  # Add space after table
                    table_header = []
                    table_rows = []
                    in_table = False
                
                # Add regular paragraph if not in code block
                if not in_code_block and not in_table:
                    doc.add_paragraph(line)
        
        # Handle any remaining list items
        if in_list:
            for item in list_items:
                p = doc.add_paragraph(style='List Bullet')
                p.add_run(item)
        
        # Handle any remaining table
        if in_table:
            table = doc.add_table(rows=1, cols=len(table_header))
            table.style = 'Table Grid'
            
            # Add header row
            header_cells = table.rows[0].cells
            for i, header in enumerate(table_header):
                header_cells[i].text = header
            
            # Add data rows
            for row_data in table_rows:
                row_cells = table.add_row().cells
                for i, cell in enumerate(row_data):
                    if i < len(row_cells):
                        row_cells[i].text = cell
        
        # Add images if provided
        if images:
            for img_id, img_data in images.items():
                doc.add_picture(io.BytesIO(img_data), width=Inches(6))
                p = doc.paragraphs[-1]
                p.alignment = WD_ALIGN_PARAGRAPH.CENTER
        
        # Add footer with generation timestamp
        section = doc.sections[0]
        footer = section.footer
        p = footer.paragraphs[0]
        p.text = f"Generated by Fairfield County Housing Market Analysis on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
        p.style = doc.styles['Footer']
        
        return doc
    
    except Exception as e:
        logger.error(f"Error converting markdown to DOCX: {str(e)}")
        # Return a simple document with the error message
        doc = Document()
        doc.add_heading("Error", 0)
        doc.add_paragraph(f"Error converting markdown to DOCX: {str(e)}")
        return doc

def markdown_to_pdf(markdown_text: str, images: Dict[str, bytes] = None) -> bytes:
    """
    Convert markdown text to PDF.
    
    Args:
        markdown_text (str): Markdown text.
        images (Dict[str, bytes], optional): Dictionary of image data keyed by image ID. Defaults to None.
    
    Returns:
        bytes: PDF data.
    """
    try:
        # Create PDF object
        pdf = FPDF()
        pdf.add_page()
        
        # Set default font
        pdf.set_font("Arial", size=12)
        
        # Convert markdown to HTML for easier processing
        html = markdown.markdown(markdown_text, extensions=['tables', 'fenced_code'])
        
        # Process HTML
        # This is a simplified approach - a full implementation would use a proper HTML parser
        lines = html.split('\n')
        
        for line in lines:
            # Handle headers
            if line.startswith('<h1>'):
                text = re.sub(r'<h1>(.*?)</h1>', r'\1', line)
                pdf.set_font("Arial", 'B', 24)
                pdf.cell(0, 10, text, ln=True)
                pdf.ln(5)
            elif line.startswith('<h2>'):
                text = re.sub(r'<h2>(.*?)</h2>', r'\1', line)
                pdf.set_font("Arial", 'B', 18)
                pdf.cell(0, 10, text, ln=True)
                pdf.ln(5)
            elif line.startswith('<h3>'):
                text = re.sub(r'<h3>(.*?)</h3>', r'\1', line)
                pdf.set_font("Arial", 'B', 14)
                pdf.cell(0, 10, text, ln=True)
                pdf.ln(5)
            elif line.startswith('<h4>'):
                text = re.sub(r'<h4>(.*?)</h4>', r'\1', line)
                pdf.set_font("Arial", 'B', 12)
                pdf.cell(0, 10, text, ln=True)
                pdf.ln(5)
            
            # Handle paragraphs
            elif line.startswith('<p>'):
                text = re.sub(r'<p>(.*?)</p>', r'\1', line)
                # Remove any HTML tags
                text = re.sub(r'<.*?>', '', text)
                pdf.set_font("Arial", size=12)
                pdf.multi_cell(0, 10, text)
                pdf.ln(5)
            
            # Skip empty lines and HTML tags we don't handle
            else:
                continue
        
        # Add images if provided
        if images:
            for img_id, img_data in images.items():
                # Save image to a temporary file
                with open(f"temp_img_{img_id}.png", "wb") as img_file:
                    img_file.write(img_data)
                
                # Add to PDF
                pdf.add_page()
                pdf.image(f"temp_img_{img_id}.png", x=10, y=10, w=190)
                
                # Clean up temporary file
                import os
                os.remove(f"temp_img_{img_id}.png")
        
        # Add generation timestamp
        pdf.set_font("Arial", size=10)
        pdf.set_text_color(128, 128, 128)  # Gray
        timestamp_text = f"Generated by Fairfield County Housing Market Analysis on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
        pdf.cell(0, 10, timestamp_text, ln=True, align='C')
        
        # Get PDF as bytes
        pdf_bytes = pdf.output(dest='S').encode('latin1')
        
        return pdf_bytes
    
    except Exception as e:
        logger.error(f"Error converting markdown to PDF: {str(e)}")
        # Return a simple PDF with the error message
        pdf = FPDF()
        pdf.add_page()
        pdf.set_font("Arial", 'B', 16)
        pdf.cell(0, 10, "Error", ln=True)
        pdf.set_font("Arial", size=12)
        pdf.multi_cell(0, 10, f"Error converting markdown to PDF: {str(e)}")
        pdf_bytes = pdf.output(dest='S').encode('latin1')
        return pdf_bytes

def format_report(report: Dict[str, Any], format_type: str = 'html', images: Dict[str, bytes] = None) -> Union[str, bytes, Document]:
    """
    Format a report for display or download.
    
    Args:
        report (Dict[str, Any]): Report data.
        format_type (str, optional): Format type ('html', 'docx', 'pdf', 'markdown'). Defaults to 'html'.
        images (Dict[str, bytes], optional): Dictionary of image data keyed by image ID. Defaults to None.
    
    Returns:
        Union[str, bytes, Document]: Formatted report.
    """
    try:
        # Extract report content
        content = report.get('content', '')
        
        # Add metadata header
        metadata = report.get('metadata', {})
        
        if metadata:
            metadata_list = [
                f"# {metadata.get('report_type', 'Housing Market').capitalize()} Analysis Report",
                f"Generated on: {metadata.get('generated_at', datetime.now().strftime('%Y-%m-%d %H:%M:%S'))}",
                f"Model: {metadata.get('provider', '').capitalize()} {metadata.get('model', '')}",
                ""
            ]
            
            # Add separator
            metadata_list.append("---")
            metadata_list.append("")
            
            # Combine with content
            content = "\n".join(metadata_list) + content
        
        # Format based on requested type
        if format_type.lower() == 'html':
            return markdown_to_html(content)
        
        elif format_type.lower() == 'docx':
            return markdown_to_docx(content, images)
        
        elif format_type.lower() == 'pdf':
            return markdown_to_pdf(content, images)
        
        elif format_type.lower() == 'markdown':
            return content
        
        else:
            logger.warning(f"Unsupported format type: {format_type}, returning markdown")
            return content
    
    except Exception as e:
        logger.error(f"Error formatting report: {str(e)}")
        if format_type.lower() == 'html':
            return f"<p>Error formatting report: {str(e)}</p>"
        elif format_type.lower() == 'docx':
            doc = Document()
            doc.add_heading("Error", 0)
            doc.add_paragraph(f"Error formatting report: {str(e)}")
            return doc
        elif format_type.lower() == 'pdf':
            pdf = FPDF()
            pdf.add_page()
            pdf.set_font("Arial", 'B', 16)
            pdf.cell(0, 10, "Error", ln=True)
            pdf.set_font("Arial", size=12)
            pdf.multi_cell(0, 10, f"Error formatting report: {str(e)}")
            pdf_bytes = pdf.output(dest='S').encode('latin1')
            return pdf_bytes
        else:
            return f"Error formatting report: {str(e)}"

def format_structured_report(report: Dict[str, Any], format_type: str = 'html', template: str = None) -> Union[str, bytes, Document]:
    """
    Format a structured report using a template.
    
    Args:
        report (Dict[str, Any]): Structured report data.
        format_type (str, optional): Format type ('html', 'docx', 'pdf', 'markdown'). Defaults to 'html'.
        template (str, optional): Template string. Defaults to None.
    
    Returns:
        Union[str, bytes, Document]: Formatted report.
    """
    try:
        # Use default template if none provided
        if template is None:
            template = """
# {title}

{subtitle}

Generated on: {date}

## Executive Summary

{executive_summary}

## Market Overview

{market_overview}

## Key Findings

{key_findings}

## Detailed Analysis

{detailed_analysis}

## Recommendations

{recommendations}

## Conclusion

{conclusion}

---

Generated using {model_info}
"""
        
        # Extract metadata
        metadata = report.get('_metadata', {})
        report_type = metadata.get('report_type', 'market')
        generated_at = metadata.get('generated_at', datetime.now().strftime('%Y-%m-%d %H:%M:%S'))
        model_info = f"{metadata.get('provider', '').capitalize()} {metadata.get('model', '')}"
        
        # Remove metadata from report copy
        report_data = {k: v for k, v in report.items() if not k.startswith('_')}
        
        # Prepare template variables
        template_vars = {
            'title': report_data.get('title', f"Fairfield County {report_type.capitalize()} Analysis"),
            'subtitle': report_data.get('subtitle', ''),
            'date': generated_at,
            'executive_summary': report_data.get('executive_summary', ''),
            'market_overview': report_data.get('market_overview', ''),
            'key_findings': report_data.get('key_findings', ''),
            'detailed_analysis': report_data.get('detailed_analysis', ''),
            'recommendations': report_data.get('recommendations', ''),
            'conclusion': report_data.get('conclusion', ''),
            'model_info': model_info
        }
        
        # Format key_findings as a list if it's a list
        if isinstance(template_vars['key_findings'], list):
            list_items = ""
            for item in template_vars['key_findings']:
                list_items += f"- {item}\n"
            template_vars['key_findings'] = list_items
        
        # Format recommendations as a list if it's a list
        if isinstance(template_vars['recommendations'], list):
            list_items = ""
            for item in template_vars['recommendations']:
                list_items += f"- {item}\n"
            template_vars['recommendations'] = list_items
        
        # Apply template
        markdown_content = template.format(**template_vars)
        
        # Format based on requested type
        return format_report({'content': markdown_content, 'metadata': metadata}, format_type)
    
    except Exception as e:
        logger.error(f"Error formatting structured report: {str(e)}")
        return format_report({
            'content': f"Error formatting structured report: {str(e)}",
            'metadata': {'error': str(e)}
        }, format_type)

def create_visual_report(report: Dict[str, Any], visualizations: Dict[str, Any], format_type: str = 'html') -> Union[str, bytes, Document]:
    """
    Create a report with embedded visualizations.
    
    Args:
        report (Dict[str, Any]): Report data.
        visualizations (Dict[str, Any]): Dictionary of visualization figures.
        format_type (str, optional): Format type ('html', 'docx', 'pdf', 'markdown'). Defaults to 'html'.
    
    Returns:
        Union[str, bytes, Document]: Formatted report with visualizations.
    """
    try:
        # Extract report content
        content = report.get('content', '')
        
        # Convert visualizations to images
        images = {}
        img_markdown = []
        
        for name, fig in visualizations.items():
            if fig is None:
                continue
            
            try:
                # Create a unique ID for the image
                img_id = f"img_{name.lower().replace(' ', '_')}"
                
                # Convert figure to image bytes
                from src.visualization.exporters import figure_to_image
                img_bytes = figure_to_image(fig, format='png')
                
                if img_bytes:
                    images[img_id] = img_bytes
                    
                    # Add image reference to markdown
                    img_markdown.append(f"\n\n## {name} Visualization\n\n![{name}]({img_id})\n\n")
            except Exception as viz_error:
                logger.error(f"Error converting visualization '{name}' to image: {str(viz_error)}")
        
        # Combine content with image references
        if img_markdown:
            content += "\n\n# Visualizations\n\n" + "\n".join(img_markdown)
        
        # Format the report with images
        return format_report({'content': content, 'metadata': report.get('metadata', {})}, format_type, images)
    
    except Exception as e:
        logger.error(f"Error creating visual report: {str(e)}")
        return format_report({
            'content': f"Error creating visual report: {str(e)}",
            'metadata': {'error': str(e)}
        }, format_type)

def export_report(report: Dict[str, Any], file_path: str, format_type: str = None, images: Dict[str, bytes] = None) -> str:
    """
    Export a report to a file.
    
    Args:
        report (Dict[str, Any]): Report data.
        file_path (str): Output file path.
        format_type (str, optional): Format type. Defaults to None (inferred from file extension).
        images (Dict[str, bytes], optional): Dictionary of image data. Defaults to None.
    
    Returns:
        str: Path to the exported file.
    """
    try:
        # Determine format type from file extension if not specified
        if format_type is None:
            ext = file_path.split('.')[-1].lower()
            if ext in ['html', 'htm']:
                format_type = 'html'
            elif ext in ['docx', 'doc']:
                format_type = 'docx'
            elif ext == 'pdf':
                format_type = 'pdf'
            elif ext in ['md', 'markdown', 'txt']:
                format_type = 'markdown'
            else:
                format_type = 'html'
                file_path += '.html'
        
        # Format the report
        formatted_report = format_report(report, format_type, images)
        
        # Create directory if it doesn't exist
        os.makedirs(os.path.dirname(os.path.abspath(file_path)), exist_ok=True)
        
        # Write to file
        if format_type == 'html' or format_type == 'markdown':
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(formatted_report)
        elif format_type == 'docx':
            formatted_report.save(file_path)
        elif format_type == 'pdf':
            with open(file_path, 'wb') as f:
                f.write(formatted_report)
        
        logger.info(f"Exported report to {file_path}")
        return file_path
    
    except Exception as e:
        logger.error(f"Error exporting report to {file_path}: {str(e)}")
        return ""
